"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var jwt = require("jsonwebtoken");
var errors_1 = require("./errors");
exports.DEFAULT_TOKEN_LEEWAY = 60 * 10;
var DEFAULT_TOKEN_EXPIRY = 24 * 60 * 60;
var CLIENT_CREDENTIALS_GRANT_TYPE = "client_credentials";
var REFRESH_TOKEN_GRANT_TYPE = "refresh_token";
var Authenticator = (function () {
    function Authenticator(appId, appKeyId, appKeySecret, 
        //Customise token expiry and leeway
        tokenExpiry, tokenLeeway) {
        this.appId = appId;
        this.appKeyId = appKeyId;
        this.appKeySecret = appKeySecret;
        this.tokenExpiry = tokenExpiry;
        this.tokenLeeway = tokenLeeway;
        if (!this.tokenExpiry) {
            this.tokenExpiry = DEFAULT_TOKEN_EXPIRY;
        }
        if (!this.tokenLeeway) {
            this.tokenLeeway = exports.DEFAULT_TOKEN_LEEWAY;
        }
    }
    Authenticator.prototype.authenticate = function (authenticatePayload, options) {
        var grantType = authenticatePayload["grant_type"];
        switch (grantType) {
            case CLIENT_CREDENTIALS_GRANT_TYPE:
                return this.authenticateWithClientCredentials(options);
            case REFRESH_TOKEN_GRANT_TYPE:
                var oldRefreshToken = authenticatePayload[REFRESH_TOKEN_GRANT_TYPE];
                return this.authenticateWithRefreshToken(oldRefreshToken, options);
            default:
                throw new errors_1.UnsupportedGrantTypeError("Requested type: \"" + grantType + "\" is not supported");
        }
    };
    Authenticator.prototype.authenticateWithClientCredentials = function (options) {
        var token = this.generateAccessToken(options).token;
        var refreshToken = this.generateRefreshToken(options);
        return {
            access_token: token,
            token_type: "bearer",
            expires_in: this.tokenExpiry,
            refresh_token: refreshToken.token,
        };
    };
    Authenticator.prototype.authenticateWithRefreshToken = function (oldRefreshToken, options) {
        var decoded;
        try {
            decoded = jwt.verify(oldRefreshToken, this.appKeySecret, {
                issuer: "keys/" + this.appKeyId,
                clockTolerance: this.tokenLeeway,
            });
        }
        catch (e) {
            var description = (e instanceof jwt.TokenExpiredError) ? "refresh token has expired" : "refresh token is invalid";
            throw new errors_1.InvalidGrantTypeError(description);
        }
        if (decoded.refresh !== true) {
            throw new errors_1.InvalidGrantTypeError("refresh token does not have a refresh claim");
        }
        if (options.userId !== decoded.sub) {
            throw new errors_1.InvalidGrantTypeError("refresh token has an invalid user id");
        }
        var newAccessToken = this.generateAccessToken(options);
        var newRefreshToken = this.generateRefreshToken(options);
        return {
            access_token: newAccessToken,
            token_type: "bearer",
            expires_in: this.tokenExpiry,
            refresh_token: newRefreshToken.token,
        };
    };
    Authenticator.prototype.generateAccessToken = function (options) {
        var now = Math.floor(Date.now() / 1000);
        var claims = __assign({ app: this.appId, iss: "api_keys/" + this.appKeyId, iat: now - this.tokenLeeway, exp: now + this.tokenExpiry - this.tokenLeeway, sub: options.userId, su: options.su }, options.serviceClaims);
        return {
            token: jwt.sign(claims, this.appKeySecret),
            expires_in: this.tokenExpiry,
        };
    };
    Authenticator.prototype.generateRefreshToken = function (options) {
        var now = Math.floor(Date.now() / 1000);
        var claims = {
            app: this.appId,
            iss: "api_keys/" + this.appKeyId,
            iat: now - this.tokenLeeway,
            refresh: true,
            sub: options.userId,
        };
        return {
            token: jwt.sign(claims, this.appKeySecret),
        };
    };
    return Authenticator;
}());
exports.default = Authenticator;
//# sourceMappingURL=authenticator.js.map